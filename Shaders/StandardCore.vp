in HIGHP vec4 in_position   : POSITION;
in LOWP vec3 in_normal      : NORMAL;
in LOWP vec4 in_color       : COLOR;
in MEDIUMP vec2 in_st       : TEXCOORD0;

#if _ALBEDO != 0 || _NORMAL != 0 || _SPECULAR != 0 || _GLOSS == 3 || _METALLIC >= 1 || (_ROUGHNESS == 1 || _ROUGHNESS == 2) || _PARALLAX != 0 || _EMISSION == 2 || _CLEARCOAT == 2 || (_CLEARCOAT != 0 && _CC_NORMAL == 1) || _ANISO == 2 || _OCC == 1
    #define NEED_BASE_TC
#endif

out VS_OUT {
    LOWP vec4 color;

#ifdef NEED_BASE_TC
    MEDIUMP vec2 tex;
#endif

#if _NORMAL == 0
    LOWP vec3 normalWS;
#endif

#if _PARALLAX
    vec3 viewTS;
#endif

#ifdef DIRECT_LIGHTING
    vec3 lightVector;
    vec3 lightFallOff;
    vec4 lightProjection;
#endif

#if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING)
    vec3 viewWS;

    #if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
        vec4 tangentToWorldAndPackedWorldPosS;
        vec4 tangentToWorldAndPackedWorldPosT;
        vec4 tangentToWorldAndPackedWorldPosR;
    #else
        vec3 positionWS;
    #endif
#endif
} vs_out;

#if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
    in LOWP vec4 in_tangent : TANGENT;
#endif

#ifdef USE_SHADOW_MAP
    $include "ShadowLibrary.vp"
#endif

#if defined(INSTANCING)
    $include "Instancing.vp"
#else
    uniform mat4x3 localToWorldMatrix;
    uniform mat3 worldToLocalMatrix;
    uniform LOWP vec4 constantColor;
#endif

#ifdef GPU_SKINNING
    #if defined(GPU_SKINNING_1_WEIGHTS)
        $include "SkinningMatrix1.glsl"
    #elif defined(GPU_SKINNING_4_WEIGHTS)
        $include "SkinningMatrix4.glsl"
    #elif defined(GPU_SKINNING_8_WEIGHTS)
        $include "SkinningMatrix8.glsl"
    #endif
#endif

uniform vec4 textureMatrixS;
uniform vec4 textureMatrixT;
uniform LOWP vec4 vertexColorScale;
uniform LOWP vec4 vertexColorAdd;

uniform vec3 viewOrigin;                // eye position in world space
uniform vec4 lightVec;                  // light position or light direction in world space
uniform mat4 viewProjectionMatrix;
uniform mat4 modelViewProjectionMatrix;

uniform vec3 lightInvRadius;
uniform mat4x3 lightFallOffMatrix;
uniform mat4 lightTextureMatrix;
uniform bool useShadowMap;

void main() {
    vec4 positionLS;
    vec3 normalLS;

#if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
    vec3 tangentLS;
    vec3 bitangentLS;

    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
        vec4 vTangent = in_tangent * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
        vec4 vTangent = in_tangent;
    #endif

    #ifdef GPU_SKINNING
        skinningMatrix(in_position, positionLS, vNormal, normalLS, vTangent, tangentLS, bitangentLS);
    #else
        positionLS = in_position;
        normalLS = vNormal;
        tangentLS = vTangent.xyz;
        bitangentLS = normalize(cross(vNormal, vTangent.xyz) * vTangent.w);
    #endif
#else
    #ifdef COMPRESSED_VERTEX_NORMAL_TANGENTS
        vec3 vNormal = in_normal.xyz * 2.0 - 1.0;
    #else
        vec3 vNormal = in_normal.xyz;
    #endif
    
    #ifdef GPU_SKINNING
        skinningMatrix(in_position, positionLS, vNormal, normalLS);
    #else
        positionLS = in_position;
        normalLS = vNormal;
    #endif
#endif

#if defined(DIRECT_LIGHTING) || defined(INDIRECT_LIGHTING)
    vec4 positionWS = vec4(localToWorldMatrix * positionLS, 1.0);

    vs_out.viewWS = viewOrigin.xyz - positionWS.xyz;

    #if _NORMAL != 0 || _ANISO != 0 || (_CLEARCOAT != 0 && _CC_NORMAL == 1)
        #if _PARALLAX
            vec3 viewLS = worldToLocalMatrix * vs_out.viewWS;

            vs_out.viewTS.x = dot(tangentLS, viewLS);
            vs_out.viewTS.y = dot(bitangentLS, viewLS);
            vs_out.viewTS.z = dot(normalLS, viewLS);
        #endif

        // Build the matrix to transform tangent space into GL world space
        vs_out.tangentToWorldAndPackedWorldPosS.xyz = mat3(localToWorldMatrix) * tangentLS;
        vs_out.tangentToWorldAndPackedWorldPosT.xyz = mat3(localToWorldMatrix) * bitangentLS;
        vs_out.tangentToWorldAndPackedWorldPosR.xyz = mat3(localToWorldMatrix) * normalLS;

        #ifdef INDIRECT_LIGHTING
            vs_out.tangentToWorldAndPackedWorldPosS.w = positionWS.x;
            vs_out.tangentToWorldAndPackedWorldPosT.w = positionWS.y;
            vs_out.tangentToWorldAndPackedWorldPosR.w = positionWS.z;
        #endif 
    #else
        vs_out.normalWS = mat3(localToWorldMatrix) * normalLS;

        vs_out.positionWS = positionWS.xyz;
    #endif
#endif

#ifdef DIRECT_LIGHTING
    // Light direction in world space
    vec3 lightWS = lightVec.xyz - lightVec.w * positionWS.xyz;

    #ifdef USE_SHADOW_MAP
        #ifdef USE_SHADOW_POINT
            ShadowCubeTransform(lightWS);
        #elif defined(USE_SHADOW_SPOT) || defined(USE_SHADOW_CASCADE)
            ShadowTransform(positionWS);
        #endif
    #endif

    vs_out.lightVector = lightWS;
    vs_out.lightProjection = lightTextureMatrix * positionWS;
    vs_out.lightFallOff = lightFallOffMatrix * positionWS;
#endif

#ifdef NEED_BASE_TC
    vs_out.tex.s = dot(textureMatrixS, vec4(in_st, 0.0, 1.0));
    vs_out.tex.t = dot(textureMatrixT, vec4(in_st, 0.0, 1.0));
#endif

#ifdef LIGHTMAP
    vs_out.tex.rq = in_st2.st;
#endif

    vs_out.color = (in_color * vertexColorScale + vertexColorAdd) * constantColor;

#ifdef INSTANCING
    gl_Position = viewProjectionMatrix * positionWS;
#else
    gl_Position = modelViewProjectionMatrix * positionLS;
#endif
}
